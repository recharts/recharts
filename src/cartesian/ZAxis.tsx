import * as React from 'react';
import { useLayoutEffect, useRef } from 'react';
import { AxisDomain, BaseAxisProps, ScaleType } from '../util/types';
import { addZAxis, AxisId, removeZAxis, replaceZAxis, ZAxisSettings } from '../state/cartesianAxisSlice';
import { useAppDispatch } from '../state/hooks';
import { AxisRange, implicitZAxis } from '../state/selectors/axisSelectors';
import { resolveDefaultProps } from '../util/resolveDefaultProps';
import { CustomScaleDefinition } from '../util/scale/CustomScaleDefinition';

function SetZAxisSettings(settings: ZAxisSettings): null {
  const dispatch = useAppDispatch();
  const prevSettingsRef = useRef<ZAxisSettings | null>(null);

  useLayoutEffect(() => {
    if (prevSettingsRef.current === null) {
      dispatch(addZAxis(settings));
    } else if (prevSettingsRef.current !== settings) {
      dispatch(replaceZAxis({ prev: prevSettingsRef.current, next: settings }));
    }
    prevSettingsRef.current = settings;
  }, [settings, dispatch]);

  useLayoutEffect(() => {
    return () => {
      if (prevSettingsRef.current) {
        dispatch(removeZAxis(prevSettingsRef.current));
        prevSettingsRef.current = null;
      }
    };
  }, [dispatch]);

  return null;
}

export interface Props extends Omit<BaseAxisProps, 'domain'> {
  /**
   * The type of axis.
   *
   * `category`: Treats data as distinct values.
   * Each value is in the same distance from its neighbors, regardless of their actual numeric difference.
   *
   * `number`: Treats data as continuous range.
   * Values that are numerically closer are placed closer together on the axis.
   *
   * @defaultValue number
   */
  type?: 'number' | 'category';
  /**
   * The unique id of z-axis.
   *
   * @defaultValue 0
   */
  zAxisId?: AxisId;
  /**
   * The range of axis.
   * Unlike other axes, the range of z-axis is not informed by chart dimensions.
   *
   * @defaultValue [64,64]
   */
  range?: AxisRange;
  /**
   * Specify the domain of axis when the axis is a number axis.
   *
   * If undefined, then the domain is calculated based on the data and dataKeys.
   *
   * The length of domain should be 2, and we will validate the values in domain.
   *
   * Each element in the array can be a number, 'auto', 'dataMin', 'dataMax', a string like 'dataMin - 20', 'dataMax + 100',
   * or a function that accepts a single argument and returns a number.
   *
   * If any element of domain is set to be 'auto', comprehensible scale ticks will be calculated, and the final domain of axis is generated by the ticks.
   * If a function, receives '[dataMin, dataMax]', and must return a computed domain as '[min, max]'.
   *
   * @example <ZAxis type="number" domain={['dataMin', 'dataMax']} />
   * @example <ZAxis type="number" domain={[0, 'dataMax']} />
   * @example <ZAxis type="number" domain={['auto', 'auto']} />
   * @example <ZAxis type="number" domain={[0, 'dataMax + 1000']} />
   * @example <ZAxis type="number" domain={['dataMin - 100', 'dataMax + 100']} />
   * @example <ZAxis type="number" domain={[dataMin => (0 - Math.abs(dataMin)), dataMax => (dataMax * 2)]} />
   * @example <ZAxis type="number" domain={([dataMin, dataMax]) => { const absMax = Math.max(Math.abs(dataMin), Math.abs(dataMax)); return [-absMax, absMax]; }} />
   * @example <ZAxis type="number" domain={[0, 100]} allowDataOverflow />
   */
  domain?: AxisDomain;
  /**
   * Scale function determines how data values are mapped to visual values.
   * In other words, decided the mapping between data domain and coordinate range.
   *
   * If undefined, or 'auto', the scale function is created internally according to the type of axis and data.
   *
   * You can define a custom scale, either as a string shortcut to a d3 scale, or as a complete scale definition object.
   *
   * @defaultValue auto
   * @example <ZAxis scale="log" />
   * @example
   * import { scaleLog } from 'd3-scale';
   * const scale = scaleLog().base(Math.E);
   * <ZAxis scale={scale} />
   */
  scale?:
    | ScaleType
    | CustomScaleDefinition
    | CustomScaleDefinition<string>
    | CustomScaleDefinition<number>
    | CustomScaleDefinition<Date>;
}

export const zAxisDefaultProps = {
  zAxisId: 0,
  range: implicitZAxis.range,
  scale: implicitZAxis.scale,
  type: implicitZAxis.type,
} as const satisfies Partial<Props>;

/**
 * Virtual axis, does not render anything itself. Has no ticks, grid lines, or labels.
 * Useful for dynamically setting Scatter point size, based on data.
 *
 * @consumes CartesianViewBoxContext
 */
export function ZAxis(outsideProps: Props) {
  const props = resolveDefaultProps(outsideProps, zAxisDefaultProps);
  return (
    <SetZAxisSettings
      domain={props.domain}
      id={props.zAxisId}
      dataKey={props.dataKey}
      name={props.name}
      unit={props.unit}
      range={props.range}
      scale={props.scale}
      type={props.type}
      allowDuplicatedCategory={implicitZAxis.allowDuplicatedCategory}
      allowDataOverflow={implicitZAxis.allowDataOverflow}
      reversed={implicitZAxis.reversed}
      includeHidden={implicitZAxis.includeHidden}
    />
  );
}

ZAxis.displayName = 'ZAxis';
