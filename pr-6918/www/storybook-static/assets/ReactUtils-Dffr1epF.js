import{q as D,r,j as h,t as L}from"./iframe-DpxBiwXt.js";import{a4 as N,D as $,q as S}from"./arrayEqualityCheck-FXkJUuOg.js";import{L as j,i as F}from"./Label-CEkR5yeX.js";import{L as R}from"./Layer-B_VW6NEu.js";import{s as K}from"./resolveDefaultProps-CEEOIjtC.js";import{Z as O}from"./ZIndexLayer-D0mBkmdS.js";import{S as Z}from"./RechartsWrapper-BjnJrxH9.js";var d={},f={},b;function M(){return b||(b=1,function(e){Object.defineProperty(e,Symbol.toStringTag,{value:"Module"});function a(t){return t[t.length-1]}e.last=a}(f)),f}var p={},v;function W(){return v||(v=1,function(e){Object.defineProperty(e,Symbol.toStringTag,{value:"Module"});function a(t){return Array.isArray(t)?t:Array.from(t)}e.toArray=a}(p)),p}var g;function U(){return g||(g=1,function(e){Object.defineProperty(e,Symbol.toStringTag,{value:"Module"});const a=M(),t=W(),o=N();function n(i){if(o.isArrayLike(i))return a.last(t.toArray(i))}e.last=n}(d)),d}var m,x;function H(){return x||(x=1,m=U().last),m}var G=H();const J=D(G),Q=e=>Array.isArray(e.value)?J(e.value):e.value,q=r.createContext(void 0),A=q.Provider,w=r.createContext(void 0),le=w.Provider;function X(){return r.useContext(q)}function Y(){return r.useContext(w)}function s({valueAccessor:e=Q,...a}){const{dataKey:t,clockWise:o,id:n,textBreakAll:i,zIndex:k,...E}=a,T=X(),V=Y(),c=T||V;return!c||!c.length?null:r.createElement(O,{zIndex:k??$.label},r.createElement(R,{className:"recharts-label-list"},c.map((l,u)=>{const z=h(t)?e(l,u):S(l.payload,t),B=h(n)?{}:{id:`${n}-${u}`};return r.createElement(j,{key:`label-${u}`,...K(l),...E,...B,fill:a.fill??l.fill,parentViewBox:l.parentViewBox,value:z,textBreakAll:i,viewBox:l.viewBox,index:u,zIndex:0})})))}s.displayName="LabelList";function C({label:e}){return e?e===!0?r.createElement(s,{key:"labelList-implicit"}):r.isValidElement(e)||F(e)?r.createElement(s,{key:"labelList-implicit",content:e}):typeof e=="object"?r.createElement(s,{key:"labelList-implicit",...e,type:String(e.type)}):null:null}try{s.displayName="LabelList",s.__docgenInfo={description:"",displayName:"LabelList",props:{valueAccessor:{defaultValue:{value:"(entry: LabelListEntry) => (Array.isArray(entry.value) ? last(entry.value) : entry.value)"},description:`The accessor function to get the value of each label. Is ignored if dataKey is specified.
@param entry
@param index`,name:"valueAccessor",required:!1,type:{name:"((entry: CartesianLabelListEntry | PolarLabelListEntry, index: number) => string | number)"}},clockWise:{defaultValue:null,description:"The parameter to calculate the view box of label in radial charts.",name:"clockWise",required:!1,type:{name:"boolean"}},dataKey:{defaultValue:null,description:`Decides how to extract the value of each label from the data:
- \`string\`: the name of the field in the data object;
- \`number\`: the index of the field in the data;
- \`function\`: a function that receives the data object and returns the value of each label.

If set, then valueAccessor will be ignored.

Scatter requires this prop to be set.
Other graphical components will show the same value as the dataKey of the component by default.`,name:"dataKey",required:!1,type:{name:"DataKey<Record<string, unknown>>"}},content:{defaultValue:null,description:`If set a React element, the option is the customized React element of rendering each label.
If set to a function, the function is called once for each item
@example <LabelList content={CustomizedLabel} />
@see {@link https://recharts.github.io/en-US/examples/BarChartWithMinHeight/ Customized content of LabelList in a BarChart}`,name:"content",required:!1,type:{name:"LabelContentType"}},textBreakAll:{defaultValue:null,description:"",name:"textBreakAll",required:!1,type:{name:"boolean"}},position:{defaultValue:null,description:"The position of label relative to the view box.",name:"position",required:!1,type:{name:"LabelPosition"}},angle:{defaultValue:null,description:`Text rotation angle in degrees.
Positive values rotate clockwise, negative values rotate counterclockwise.
@defaultValue 0`,name:"angle",required:!1,type:{name:"number"}},formatter:{defaultValue:null,description:`Function to customize how content is serialized before rendering.

This should return a renderable text - something that the {@link Text} component can render.
Typically, a string or number.
Custom components are not supported here - use the \`content\` prop instead.`,name:"formatter",required:!1,type:{name:"LabelFormatter"}},zIndex:{defaultValue:null,description:`Z-Index of this component and its children. The higher the value,
the more on top it will be rendered.
Components with higher zIndex will appear in front of components with lower zIndex.
If undefined or 0, the content is rendered in the default layer without portals.
@since 3.4
@defaultValue 2000
@see {@link https://recharts.github.io/en-US/guide/zIndex/ Z-Index and layers guide}`,name:"zIndex",required:!1,type:{name:"number"}}}}}catch{}try{C.displayName="LabelListFromLabelProp",C.__docgenInfo={description:"",displayName:"LabelListFromLabelProp",props:{label:{defaultValue:null,description:"",name:"label",required:!1,type:{name:"ImplicitLabelListType"}}}}}catch{}try{A.displayName="CartesianLabelListContextProvider",A.__docgenInfo={description:"",displayName:"CartesianLabelListContextProvider",props:{}}}catch{}const _=e=>typeof e=="string"?e:e?e.displayName||e.name||"Component":"";let I=null,y=null;const P=e=>{if(e===I&&Array.isArray(y))return y;let a=[];return r.Children.forEach(e,t=>{h(t)||(Z.isFragment(t)?a=a.concat(P(t.props.children)):a.push(t))}),y=a,I=e,a};function se(e,a){const t=[];let o=[];return Array.isArray(a)?o=a.map(n=>_(n)):o=[_(a)],P(e).forEach(n=>{const i=L(n,"type.displayName")||L(n,"type.name");i&&o.indexOf(i)!==-1&&t.push(n)}),t}const ue=e=>e&&typeof e=="object"&&"clipDot"in e?!!e.clipDot:!0;export{A as C,s as L,le as P,C as a,se as f,ue as i,J as l};
