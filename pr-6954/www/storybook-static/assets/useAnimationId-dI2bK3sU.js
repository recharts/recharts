import{u as M,r as g,n as P,G as j,o as _}from"./iframe-Bsm65lpu.js";import{r as J}from"./resolveDefaultProps-rxG_-3GU.js";const U=e=>e.replace(/([A-Z])/g,t=>`-${t.toLowerCase()}`),k=(e,t,n)=>e.map(i=>`${U(i)} ${t}ms ${n}`).join(","),N=(e,t)=>[Object.keys(e),Object.keys(t)].reduce((n,i)=>n.filter(a=>i.includes(a))),y=(e,t)=>Object.keys(t).reduce((n,i)=>({...n,[i]:e(i,t[i])}),{}),A=(e,t,n)=>e+(t-e)*n,T=({from:e,to:t})=>e!==t,B=(e,t,n)=>{const i=y((a,r)=>{if(T(r)){const[s,c]=e(r.from,r.to,r.velocity);return{...r,from:s,velocity:c}}return r},t);return n<1?y((a,r)=>T(r)&&i[a]!=null?{...r,velocity:A(r.velocity,i[a].velocity,n),from:A(r.from,i[a].from,n)}:r,t):B(e,i,n-1)};function O(e,t,n,i,a,r){let s,c=i.reduce((l,p)=>({...l,[p]:{from:e[p],velocity:0,to:t[p]}}),{});const f=()=>y((l,p)=>p.from,c),m=()=>!Object.values(c).filter(T).length;let u=null;const o=l=>{s||(s=l);const d=(l-s)/n.dt;c=B(n,c,d),a({...e,...t,...f()}),s=l,m()||(u=r.setTimeout(o))};return()=>(u=r.setTimeout(o),()=>{u==null||u()})}function R(e,t,n,i,a,r,s){let c=null;const f=a.reduce((o,l)=>{const p=e[l],d=t[l];return p==null||d==null?o:{...o,[l]:[p,d]}},{});let m;const u=o=>{m||(m=o);const l=(o-m)/i,p=y((d,h)=>A(...h,n(l)),f);if(r({...e,...t,...p}),l<1)c=s.setTimeout(u);else{const d=y((h,S)=>A(...S,n(1)),f);r({...e,...t,...d})}};return()=>(c=s.setTimeout(u),()=>{c==null||c()})}const F=(e,t,n,i,a,r)=>{const s=N(e,t);return n==null?()=>(a({...e,...t}),()=>{}):n.isStepper===!0?O(e,t,n,s,a,r):R(e,t,n,i,s,a,r)},b=1e-4,z=(e,t)=>[0,3*e,3*t-6*e,3*e-3*t+1],C=(e,t)=>e.map((n,i)=>n*t**i).reduce((n,i)=>n+i),w=(e,t)=>n=>{const i=z(e,t);return C(i,n)},$=(e,t)=>n=>{const a=[...z(e,t).map((r,s)=>r*s).slice(1),0];return C(a,n)},D=e=>{var a,r;const t=e.split("(");if(t.length!==2||t[0]!=="cubic-bezier")return null;const n=(r=(a=t[1])==null?void 0:a.split(")")[0])==null?void 0:r.split(",");if(n==null||n.length!==4)return null;const i=n.map(s=>parseFloat(s));return[i[0],i[1],i[2],i[3]]},G=(...e)=>{if(e.length===1)switch(e[0]){case"linear":return[0,0,1,1];case"ease":return[.25,.1,.25,1];case"ease-in":return[.42,0,1,1];case"ease-out":return[.42,0,.58,1];case"ease-in-out":return[0,0,.58,1];default:{const t=D(e[0]);if(t)return t}}return e.length===4?e:[0,0,1,1]},K=(e,t,n,i)=>{const a=w(e,n),r=w(t,i),s=$(e,n),c=m=>m>1?1:m<0?0:m,f=m=>{const u=m>1?1:m;let o=u;for(let l=0;l<8;++l){const p=a(o)-u,d=s(o);if(Math.abs(p-u)<b||d<b)return r(o);o=c(o-p/d)}return r(o)};return f.isStepper=!1,f},I=(...e)=>K(...G(...e)),Y=(e={})=>{const{stiff:t=100,damping:n=8,dt:i=17}=e,a=(r,s,c)=>{const f=-(r-s)*t,m=c*n,u=c+(f-m)*i/1e3,o=c*i/1e3+r;return Math.abs(o-s)<b&&Math.abs(u)<b?[s,0]:[o,u]};return a.isStepper=!0,a.dt=i,a},x=e=>{if(typeof e=="string")switch(e){case"ease":case"ease-in-out":case"ease-out":case"ease-in":case"linear":return I(e);case"spring":return Y();default:if(e.split("(")[0]==="cubic-bezier")return I(e)}return typeof e=="function"?e:null},L={begin:0,duration:1e3,easing:"ease",isActive:!0,canBegin:!0,onAnimationEnd:()=>{},onAnimationStart:()=>{}},V={t:0},v={t:1};function q(e){const t=J(e,L),{isActive:n,canBegin:i,duration:a,easing:r,begin:s,onAnimationEnd:c,onAnimationStart:f,children:m}=t,u=n==="auto"?!j.isSsr:n,o=M(t.animationId,t.animationManager),[l,p]=g.useState(u?V:v),d=g.useRef(null);return g.useEffect(()=>{u||p(v)},[u]),g.useEffect(()=>{if(!u||!i)return P;const h=F(V,v,x(r),a,p,o.getTimeoutController()),S=()=>{d.current=h()};return o.start([f,s,S,a,c]),()=>{o.stop(),d.current&&d.current(),c()}},[u,i,a,r,s,f,c,o]),m(l.t)}try{q.displayName="JavascriptAnimate",q.__docgenInfo={description:"",displayName:"JavascriptAnimate",props:{animationId:{defaultValue:null,description:"",name:"animationId",required:!0,type:{name:"string"}},animationManager:{defaultValue:null,description:"",name:"animationManager",required:!1,type:{name:"AnimationManager"}},duration:{defaultValue:null,description:"",name:"duration",required:!1,type:{name:"number"}},begin:{defaultValue:null,description:"",name:"begin",required:!1,type:{name:"number"}},easing:{defaultValue:null,description:"",name:"easing",required:!1,type:{name:"EasingInput"}},isActive:{defaultValue:null,description:"",name:"isActive",required:!1,type:{name:'boolean | "auto"'}},canBegin:{defaultValue:null,description:"",name:"canBegin",required:!1,type:{name:"boolean"}},onAnimationStart:{defaultValue:null,description:"",name:"onAnimationStart",required:!1,type:{name:"(() => void)"}},onAnimationEnd:{defaultValue:null,description:"",name:"onAnimationEnd",required:!1,type:{name:"(() => void)"}}}}}catch{}function E(e,t="animation-"){const n=g.useRef(_(t)),i=g.useRef(e);return i.current!==e&&(n.current=_(t),i.current=e),n.current}try{E.displayName="useAnimationId",E.__docgenInfo={description:`This hook returns a unique animation id for the object input.
If input changes (as in, reference equality is different), the animation id will change.
If input does not change, the animation id will not change.

This is useful for animations. The Animate component
does have a \`shouldReAnimate\` prop but that doesn't seem to be doing what the name implies.
Also, we don't always want to re-animate on every render;
we only want to re-animate when the input changes. Not the internal state (e.g. \`isAnimating\`).`,displayName:"useAnimationId",props:{}}}catch{}export{q as J,k as g,E as u};
