import { vi } from 'vitest';
import { getTicks, GetTicksInput } from '../../src/cartesian/getTicks';
import { CartesianTickItem, TickItem } from '../../src/util/types';

const EXAMPLE_INPUT: GetTicksInput = {
  tickFormatter: undefined,
  unit: '',
  angle: undefined,
  interval: 'preserveStart' as const,
  minTickGap: 5,
  orientation: 'bottom' as const,
  tick: true,
  ticks: [
    {
      value: '10',
      coordinate: 50,
      index: 0,
    },
    {
      value: '1000',
      coordinate: 100,
      index: 1,
    },
    {
      value: '20',
      coordinate: 150,
      index: 2,
    },
    {
      value: '40',
      coordinate: 200,
      index: 3,
    },
    {
      value: '90',
      coordinate: 250,
      index: 4,
    },
    {
      value: 'A',
      coordinate: 300,
      index: 5,
    },
  ],
  viewBox: { x: 0, y: 0, width: 500, height: 500 },
};

vi.mock('../../src/util/DOMUtils', () => ({
  // We mock string size measurement, because getStringSize else returns 0 in these tests.
  getStringSize: vi.fn((text: string) => ({ width: text.length, height: 12 })),
}));

// These tests have been generated by merely documenting existing behaviour.
// They will be used to verify that any refactoring does not break the existing behaviour.
describe('getTicks', () => {
  describe('ticks are always shown if there is space', () => {
    test('preserveEnd', () => {
      const input: GetTicksInput = { ...EXAMPLE_INPUT, interval: 'preserveEnd' as const };

      const result = getTicks(input);

      expect(result).toEqual([
        { value: '10', coordinate: 50, tickCoord: 50, isShow: true, index: 0 },
        { value: '1000', coordinate: 100, tickCoord: 100, isShow: true, index: 1 },
        { value: '20', coordinate: 150, tickCoord: 150, isShow: true, index: 2 },
        { value: '40', coordinate: 200, tickCoord: 200, isShow: true, index: 3 },
        { value: '90', coordinate: 250, tickCoord: 250, isShow: true, index: 4 },
        { value: 'A', coordinate: 300, tickCoord: 300, isShow: true, index: 5 },
      ]);
    });

    test('preserveStart', () => {
      const input = { ...EXAMPLE_INPUT, interval: 'preserveStart' as const };

      const result = getTicks(input);

      expect(result).toEqual([
        { value: '10', coordinate: 50, tickCoord: 50, isShow: true, index: 0 },
        { value: '1000', coordinate: 100, tickCoord: 100, isShow: true, index: 1 },
        { value: '20', coordinate: 150, tickCoord: 150, isShow: true, index: 2 },
        { value: '40', coordinate: 200, tickCoord: 200, isShow: true, index: 3 },
        { value: '90', coordinate: 250, tickCoord: 250, isShow: true, index: 4 },
        { value: 'A', coordinate: 300, tickCoord: 300, isShow: true, index: 5 },
      ]);
    });
  });

  describe('ticks are shown if there is space when displayed at an angle', () => {
    test('preserveEnd', () => {
      const ticks: ReadonlyArray<TickItem> = [
        { value: '100_000_000_000_000', coordinate: 50, index: 0 },
        { value: '200_000_000_000_000', coordinate: 70, index: 1 },
        { value: '300_000_000_000_000', coordinate: 90, index: 2 },
        { value: '400_000_000_000_000', coordinate: 110, index: 3 },
        { value: '500_000_000_000_000', coordinate: 130, index: 4 },
        { value: '600_000_000_000_000', coordinate: 150, index: 5 },
      ];
      const input = { ...EXAMPLE_INPUT, ticks, interval: 'preserveEnd' as const };

      // Only 3 ticks are shown
      expect(getTicks(input)).toEqual([
        { value: '200_000_000_000_000', coordinate: 70, tickCoord: 70, isShow: true, index: 1 },
        { value: '400_000_000_000_000', coordinate: 110, tickCoord: 110, isShow: true, index: 3 },
        { value: '600_000_000_000_000', coordinate: 150, tickCoord: 150, isShow: true, index: 5 },
      ]);

      const angledInput = { ...input, angle: 60 };

      // But at an angle we can fit all ticks
      expect(getTicks(angledInput)).toEqual([
        { value: '100_000_000_000_000', coordinate: 50, tickCoord: 50, isShow: true, index: 0 },
        { value: '200_000_000_000_000', coordinate: 70, tickCoord: 70, isShow: true, index: 1 },
        { value: '300_000_000_000_000', coordinate: 90, tickCoord: 90, isShow: true, index: 2 },
        { value: '400_000_000_000_000', coordinate: 110, tickCoord: 110, isShow: true, index: 3 },
        { value: '500_000_000_000_000', coordinate: 130, tickCoord: 130, isShow: true, index: 4 },
        { value: '600_000_000_000_000', coordinate: 150, tickCoord: 150, isShow: true, index: 5 },
      ]);
    });

    test('preserveStart', () => {
      const ticks: ReadonlyArray<TickItem> = [
        { value: '100_000_000_000_000', coordinate: 50, index: 0 },
        { value: '200_000_000_000_000', coordinate: 70, index: 1 },
        { value: '300_000_000_000_000', coordinate: 90, index: 2 },
        { value: '400_000_000_000_000', coordinate: 110, index: 3 },
        { value: '500_000_000_000_000', coordinate: 130, index: 4 },
        { value: '600_000_000_000_000', coordinate: 150, index: 5 },
      ];
      const input = { ...EXAMPLE_INPUT, ticks, interval: 'preserveStart' as const };

      // Only 3 ticks are shown
      expect(getTicks(input)).toEqual([
        { value: '100_000_000_000_000', coordinate: 50, tickCoord: 50, isShow: true, index: 0 },
        { value: '300_000_000_000_000', coordinate: 90, tickCoord: 90, isShow: true, index: 2 },
        { value: '500_000_000_000_000', coordinate: 130, tickCoord: 130, isShow: true, index: 4 },
      ]);

      const angledInput = { ...input, angle: 60 };

      // But at an angle we can fit all ticks
      expect(getTicks(angledInput)).toEqual([
        { value: '100_000_000_000_000', coordinate: 50, tickCoord: 50, isShow: true, index: 0 },
        { value: '200_000_000_000_000', coordinate: 70, tickCoord: 70, isShow: true, index: 1 },
        { value: '300_000_000_000_000', coordinate: 90, tickCoord: 90, isShow: true, index: 2 },
        { value: '400_000_000_000_000', coordinate: 110, tickCoord: 110, isShow: true, index: 3 },
        { value: '500_000_000_000_000', coordinate: 130, tickCoord: 130, isShow: true, index: 4 },
        { value: '600_000_000_000_000', coordinate: 150, tickCoord: 150, isShow: true, index: 5 },
      ]);
    });
  });

  describe('The interval is respected', () => {
    const viewBoxWithSmallWidth = { x: 0, y: 0, width: 30, height: 500 };

    test.each([
      [
        EXAMPLE_INPUT.ticks.length + 1,
        [
          {
            coordinate: 50,
            value: '10',
            index: 0,
          },
        ],
      ],
      [
        2,
        [
          {
            coordinate: 50,
            value: '10',
            index: 0,
          },
          {
            coordinate: 200,
            value: '40',
            index: 3,
          },
        ],
      ],
      [
        1,
        [
          {
            coordinate: 50,
            value: '10',
            index: 0,
          },
          {
            coordinate: 150,
            value: '20',
            index: 2,
          },
          {
            coordinate: 250,
            value: '90',
            index: 4,
          },
        ],
      ],
      [
        0,
        [
          {
            coordinate: 50,
            value: '10',
            index: 0,
          },
          {
            coordinate: 100,
            value: '1000',
            index: 1,
          },
          {
            coordinate: 150,
            value: '20',
            index: 2,
          },
          {
            coordinate: 200,
            value: '40',
            index: 3,
          },
          {
            coordinate: 250,
            value: '90',
            index: 4,
          },
          {
            coordinate: 300,
            value: 'A',
            index: 5,
          },
        ],
      ],
      [
        'preserveStartEnd' as const,
        [
          {
            coordinate: 300,
            isShow: true,
            tickCoord: 29.5,
            value: 'A',
            index: 5,
          },
        ],
      ],
      ['preserveStart' as const, []],
      [
        'preserveEnd' as const,
        [
          {
            coordinate: 300,
            isShow: true,
            tickCoord: 29.5,
            value: 'A',
            index: 5,
          },
        ],
      ],
      [
        'equidistantPreserveStart' as const,
        [
          {
            coordinate: 50,
            value: '10',
            index: 0,
          },
        ],
      ],
      [-1, []],
      [undefined, [{ coordinate: 300, isShow: true, tickCoord: 29.5, value: 'A', index: 5 }]],
    ])(`interval %s works`, (interval, expectedResult) => {
      const input = {
        ...EXAMPLE_INPUT,
        interval,
        viewBox: viewBoxWithSmallWidth,
      };

      const result = getTicks(input);

      expect(result).toEqual(expectedResult);
    });
  });

  describe('Equidistant ticks are shown depending on label width and space between ticks', () => {
    test.each([
      // With enough space, all ticks are shown.
      [['11111111111111', '2', '3', '4'], 20, ['11111111111111', '2', '3', '4']],
      [['1', '22222222222222', '3', '4'], 20, ['1', '22222222222222', '3', '4']],
      [['1', '2', '33333333333333', '4'], 20, ['1', '2', '33333333333333', '4']],
      [['1', '2', '3', '44444444444444'], 20, ['1', '2', '3', '44444444444444']],

      // If not enough space is available we show only every nTH.
      [['11111111111111', '2', '3', '4'], 5, ['11111111111111', '4']], // every 3rd
      [['1', '22222222222222', '3', '4'], 5, ['1', '3']], // every 2nd
      [['1', '2', '33333333333333', '4'], 5, ['1', '4']], // every 3rd
      [['1', '2', '3', '44444444444444'], 5, ['1', '3']], // every 2nd

      // If not enough space is available at all, we only show the first tick.
      [['11111111111111', '2', '3', '4'], 1, ['11111111111111']],
      [['1', '22222222222222', '3', '4'], 1, ['1']],
      [['1', '2', '33333333333333', '4'], 1, ['1']],
      [['1', '2', '3', '44444444444444'], 1, ['1']],
    ])(
      `equidistantPreserveStart spaces nicely for %s and tick step of %s`,
      (tickValues, tickWidthStep, expectedResult) => {
        const ticks: ReadonlyArray<TickItem> = tickValues.map(
          (value, index): TickItem => ({
            value,
            coordinate: tickWidthStep * (index + 1),
            index,
          }),
        );
        const input = {
          ...EXAMPLE_INPUT,
          interval: 'equidistantPreserveStart' as const,
          ticks,
        };

        const resultingTickValues = (getTicks(input) as CartesianTickItem[]).map(tick => tick.value);

        expect(resultingTickValues).toEqual(expectedResult);
      },
    );
  });
});
