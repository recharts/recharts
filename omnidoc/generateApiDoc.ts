/**
 * @fileOverview Auto-generates API documentation files from TypeScript source code
 *
 * This tool generates API documentation in the www/src/docs/api folder
 * by reading TypeScript comments and type definitions from the source code.
 *
 * Usage:
 *   npm run omnidoc
 *
 * The generated files will always overwrite existing files - no merging is attempted.
 * Only en-US descriptions are generated from the TypeScript documentation.
 */
import * as fs from 'fs';
import * as path from 'path';
import { marked } from 'marked';
import { ProjectDocReader } from './readProject';
import { ApiDoc, ApiProps } from '../www/src/docs/api/types';

/**
 * List of components that are ready to be auto-generated.
 * If no components are specified on the command line, these will be generated.
 * Components not in this list can still be generated by passing them as arguments.
 */
export const OMNIDOC_AUTOMATED_API_DOCS_COMPONENTS: string[] = [
  // Add components here as they become ready for auto-generation by default
  'BarStack',
  'Text',
];

const OUTPUT_DIR = path.join(__dirname, '../www/src/docs/api');

/**
 * Converts a TypeScript type to a simplified string representation for API docs
 */
function simplifyType(originalText: string): string {
  let simplifiedText: string = originalText;
  // Remove import paths - extract just the type name
  const importMatch = simplifiedText.match(/import\([^)]+\)\.(\w+)/);
  if (importMatch) {
    const [, second] = importMatch;
    simplifiedText = second;
  }

  // Handle union types with undefined (optional types)
  if (simplifiedText.includes(' | undefined')) {
    simplifiedText = simplifiedText.replace(' | undefined', '');
  }

  // Handle union types
  if (simplifiedText.includes(' | ')) {
    const parts = simplifiedText.split(' | ').map(p => simplifyType(p.trim()));
    const uniqueParts = Array.from(new Set(parts));

    // If it's a simple union, join with |
    if (uniqueParts.length <= 4) {
      return uniqueParts.join(' | ');
    }
    // For complex unions, just return a generic type
    return `(union of ${uniqueParts.length} variants)`;
  }

  // Array types
  if (simplifiedText.endsWith('[]')) {
    const elementType = simplifyType(simplifiedText.slice(0, -2));
    return `Array<${elementType}>`;
  }
  if (simplifiedText.startsWith('Array<') || simplifiedText.startsWith('ReadonlyArray<')) {
    return 'Array';
  }

  // Function types
  if (simplifiedText.includes('=>') || (simplifiedText.startsWith('(') && simplifiedText.includes(')'))) {
    return 'Function';
  }

  // React types
  if (
    simplifiedText.includes('ReactNode') ||
    simplifiedText.includes('ReactElement') ||
    simplifiedText.includes('JSX.Element')
  ) {
    return 'ReactNode';
  }

  // Object types
  if (simplifiedText.startsWith('{') || simplifiedText === 'object') {
    return 'Object';
  }

  // Return as-is if it's a simple type name (could be a custom type)
  return simplifiedText;
}

/**
 * Generates API documentation for a single component
 */
async function generateApiDoc(componentName: string, projectReader: ProjectDocReader): Promise<ApiDoc> {
  const props: ApiProps[] = [];
  const rechartsPropNames = projectReader.getRechartsPropsOf(componentName);

  for (const propName of rechartsPropNames) {
    const comment = projectReader.getCommentOf(componentName, propName);
    const defaultValue = projectReader.getDefaultValueOf(componentName, propName);

    // Extract type information
    const typeText = projectReader.getTypeOf(componentName, propName);
    const typeString = typeText ? simplifyType(typeText) : 'Any';

    // Determine if optional
    const isOptional = projectReader.isOptionalProp(componentName, propName);

    const prop: ApiProps = {
      name: propName,
      type: typeString,
      isOptional,
    };

    // Add description if available
    if (comment) {
      prop.desc = {
        // eslint-disable-next-line no-await-in-loop
        'en-US': await marked.parse(comment),
      };
    }

    // Add default value if available
    if (defaultValue.type === 'known') {
      prop.defaultVal = defaultValue.value as
        | string
        | number
        | boolean
        | Array<unknown>
        | Record<string, unknown>
        | null;
    }

    props.push(prop);
  }

  return {
    name: componentName,
    props,
  };
}

/**
 * Custom stringify that converts HTML strings to JSX
 */
function stringifyApiDoc(apiDoc: ApiDoc): string {
  let result = `{"name": "${apiDoc.name}","props": [`;

  apiDoc.props.forEach(prop => {
    result += `{`;
    result += `"name": "${prop.name}",`;
    result += `"type": "${prop.type}",`;
    result += `"isOptional": ${prop.isOptional},`;

    if (prop.desc) {
      result += `"desc": {`;
      for (const [locale, html] of Object.entries(prop.desc)) {
        // Write HTML as JSX without quotes. Wrap in <section> to ensure valid JSX.
        result += `"${locale}": (<section>${html}</section>),`;
      }
      result += `},`;
    }

    if (prop.defaultVal !== undefined) {
      result += `"defaultVal": ${JSON.stringify(prop.defaultVal)},`;
    }

    result += `},`;
  });

  result += `],}`;
  return result;
}

/**
 * Writes the API doc to a TypeScript file
 */
function writeApiDocFile(apiDoc: ApiDoc, outputPath: string): void {
  const varName = `${apiDoc.name}API`;

  const fileContent = `import { ApiDoc } from './types.ts';

export const ${varName}: ApiDoc = ${stringifyApiDoc(apiDoc)};
`;

  fs.writeFileSync(outputPath, fileContent, 'utf-8');
  console.log(`✓ Generated ${outputPath}`);
}

/**
 * Main function
 */
async function main() {
  const componentsToGenerate = OMNIDOC_AUTOMATED_API_DOCS_COMPONENTS;

  const projectReader = new ProjectDocReader();

  console.log('Generating API documentation for:', componentsToGenerate);

  for (const componentName of componentsToGenerate) {
    try {
      // eslint-disable-next-line no-await-in-loop
      const apiDoc = await generateApiDoc(componentName, projectReader);
      const outputPath = path.join(OUTPUT_DIR, `${componentName}API.tsx`);
      writeApiDocFile(apiDoc, outputPath);
    } catch (error) {
      console.error(`✗ Failed to generate documentation for ${componentName}:`, error);
    }
  }

  console.log('\nDone! Remember to:');
  console.log('1. Review the generated files');
  console.log('2. Add imports to www/src/docs/api/index.ts if needed');
  console.log('3. Run tests to verify consistency');
}

if (require.main === module) {
  main();
}

export { generateApiDoc, writeApiDocFile };
