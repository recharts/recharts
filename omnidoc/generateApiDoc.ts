/**
 * @fileOverview Auto-generates API documentation files from TypeScript source code
 *
 * This tool generates API documentation in the www/src/docs/api folder
 * by reading TypeScript comments and type definitions from the source code.
 *
 * Usage:
 *   npm run generate-api-doc [component1] [component2] ...
 *
 * Examples:
 *   npm run generate-api-doc CartesianGrid
 *   npm run generate-api-doc CartesianGrid XAxis YAxis
 *
 * The generated files will always overwrite existing files - no merging is attempted.
 * Only en-US descriptions are generated from the TypeScript documentation.
 */
import * as fs from 'fs';
import * as path from 'path';
import { ProjectDocReader } from './readProject';
import { ApiDoc, ApiProps } from '../www/src/docs/api/types';

/**
 * List of components that are ready to be auto-generated.
 * If no components are specified on the command line, these will be generated.
 * Components not in this list can still be generated by passing them as arguments.
 */
const ALLOWLISTED_COMPONENTS: string[] = [
  // Add components here as they become ready for auto-generation by default
  'BarStack',
];

const OUTPUT_DIR = path.join(__dirname, '../www/src/docs/api');

/**
 * Converts a TypeScript type to a simplified string representation for API docs
 */
function simplifyType(originalText: string): string {
  let simplifiedText: string = originalText;
  // Remove import paths - extract just the type name
  const importMatch = simplifiedText.match(/import\([^)]+\)\.(\w+)/);
  if (importMatch) {
    const [, second] = importMatch;
    simplifiedText = second;
  }

  // Handle union types with undefined (optional types)
  if (simplifiedText.includes(' | undefined')) {
    simplifiedText = simplifiedText.replace(' | undefined', '');
  }

  // Handle union types
  if (simplifiedText.includes(' | ')) {
    const parts = simplifiedText.split(' | ').map(p => simplifyType(p.trim()));
    const uniqueParts = Array.from(new Set(parts));

    // If it's a simple union, join with |
    if (uniqueParts.length <= 4) {
      return uniqueParts.join(' | ');
    }
    // For complex unions, just return a generic type
    return `(union of ${uniqueParts.length} variants)`;
  }

  // Array types
  if (simplifiedText.endsWith('[]')) {
    const elementType = simplifyType(simplifiedText.slice(0, -2));
    return `Array<${elementType}>`;
  }
  if (simplifiedText.startsWith('Array<') || simplifiedText.startsWith('ReadonlyArray<')) {
    return 'Array';
  }

  // Function types
  if (simplifiedText.includes('=>') || (simplifiedText.startsWith('(') && simplifiedText.includes(')'))) {
    return 'Function';
  }

  // React types
  if (
    simplifiedText.includes('ReactNode') ||
    simplifiedText.includes('ReactElement') ||
    simplifiedText.includes('JSX.Element')
  ) {
    return 'ReactNode';
  }

  // Object types
  if (simplifiedText.startsWith('{') || simplifiedText === 'object') {
    return 'Object';
  }

  // Return as-is if it's a simple type name (could be a custom type)
  return simplifiedText;
}

/**
 * Generates API documentation for a single component
 */
function generateApiDoc(componentName: string, projectReader: ProjectDocReader): ApiDoc {
  const props: ApiProps[] = [];
  const rechartsPropNames = projectReader.getRechartsPropsOf(componentName);

  for (const propName of rechartsPropNames) {
    const comment = projectReader.getCommentOf(componentName, propName);
    const defaultValue = projectReader.getDefaultValueOf(componentName, propName);

    // Extract type information
    const typeText = projectReader.getTypeOf(componentName, propName);
    const typeString = typeText ? simplifyType(typeText) : 'Any';

    // Determine if optional
    const isOptional = projectReader.isOptionalProp(componentName, propName);

    const prop: ApiProps = {
      name: propName,
      type: typeString,
      isOptional,
    };

    // Add description if available
    if (comment) {
      prop.desc = {
        'en-US': comment,
      };
    }

    // Add default value if available
    if (defaultValue.type === 'known') {
      prop.defaultVal = defaultValue.value as
        | string
        | number
        | boolean
        | Array<unknown>
        | Record<string, unknown>
        | null;
    }

    props.push(prop);
  }

  return {
    name: componentName,
    props,
  };
}

/**
 * Writes the API doc to a TypeScript file
 */
function writeApiDocFile(apiDoc: ApiDoc, outputPath: string): void {
  const varName = `${apiDoc.name}API`;

  const fileContent = `import { ApiDoc } from './types.ts';

export const ${varName}: ApiDoc = ${JSON.stringify(apiDoc, null, 2)};
`;

  fs.writeFileSync(outputPath, fileContent, 'utf-8');
  console.log(`✓ Generated ${outputPath}`);
}

/**
 * Main function
 */
function main() {
  const args = process.argv.slice(2);
  const componentsToGenerate = args.length > 0 ? args : ALLOWLISTED_COMPONENTS;

  if (componentsToGenerate.length === 0) {
    console.error('Error: No components specified.');
    console.error('Usage: npm run generate-api-doc [component1] [component2] ...');
    console.error('Or add components to the ALLOWLISTED_COMPONENTS array in this file.');
    process.exit(1);
  }

  const projectReader = new ProjectDocReader();

  console.log('Generating API documentation for:', componentsToGenerate);

  for (const componentName of componentsToGenerate) {
    try {
      const apiDoc = generateApiDoc(componentName, projectReader);
      const outputPath = path.join(OUTPUT_DIR, `${componentName}.ts`);
      writeApiDocFile(apiDoc, outputPath);
    } catch (error) {
      console.error(`✗ Failed to generate documentation for ${componentName}:`, error);
    }
  }

  console.log('\nDone! Remember to:');
  console.log('1. Review the generated files');
  console.log('2. Add imports to www/src/docs/api/index.ts if needed');
  console.log('3. Run tests to verify consistency');
}

if (require.main === module) {
  main();
}

export { generateApiDoc, writeApiDocFile };
