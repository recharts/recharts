/**
 * @fileOverview Auto-generates API documentation files from TypeScript source code
 *
 * This tool generates API documentation in the www/src/docs/api folder
 * by reading TypeScript comments and type definitions from the source code.
 *
 * Usage:
 *   npm run omnidoc
 *
 * The generated files will always overwrite existing files - no merging is attempted.
 * Only en-US descriptions are generated from the TypeScript documentation.
 */
import * as fs from 'fs';
import * as path from 'path';
import { marked } from 'marked';
import { getAllTagTexts, getTagText, ProjectDocReader } from './readProject';
import { ApiDoc, ApiProps } from '../www/src/docs/api/types';

/**
 * List of components that are ready to be auto-generated.
 * If no components are specified on the command line, these will be generated.
 * Components not in this list can still be generated by passing them as arguments.
 */
export const OMNIDOC_AUTOMATED_API_DOCS_COMPONENTS: string[] = [
  // Add components here as they become ready for auto-generation by default
  'Area',
  'BarStack',
  'Text',
  'Label',
  'ZIndexLayer',
];

const OUTPUT_DIR = path.join(__dirname, '../www/src/docs/api');

/**
 * Converts a TypeScript type to a simplified string representation for API docs
 */
function simplifyType(originalText: string, isInline: boolean = false): string {
  let simplifiedText: string = originalText;
  // Remove import paths - extract just the type name
  simplifiedText = simplifiedText.replace(/import\([^)]+\)\.(\w+)/g, '$1');

  // Handle union types
  if (simplifiedText.includes(' | ')) {
    const parts = simplifiedText
      .split(' | ')
      .map(p => p.trim())
      .filter(p => p !== 'undefined')
      .map(p => simplifyType(p));

    const uniqueParts = Array.from(new Set(parts));

    // If it's a simple union, join with |
    if (isInline || uniqueParts.length <= 4) {
      if (uniqueParts.length === 0) return 'undefined';
      return uniqueParts.join(' | ');
    }
    // For complex unions, just return a generic type
    return `(union of ${uniqueParts.length} variants)`;
  }

  // Array types
  if (simplifiedText.endsWith('[]')) {
    const elementType = simplifyType(simplifiedText.slice(0, -2));
    return `Array<${elementType}>`;
  }
  if (simplifiedText.startsWith('Array<') || simplifiedText.startsWith('ReadonlyArray<')) {
    return 'Array';
  }

  // Function types
  if (simplifiedText.includes('=>') || (simplifiedText.startsWith('(') && simplifiedText.includes(')'))) {
    return 'Function';
  }

  // React types
  if (
    simplifiedText.includes('ReactNode') ||
    simplifiedText.includes('ReactElement') ||
    simplifiedText.includes('JSX.Element')
  ) {
    return 'ReactNode';
  }

  // Object types
  if (simplifiedText.startsWith('{') || simplifiedText === 'object') {
    return 'Object';
  }

  // Return as-is if it's a simple type name (could be a custom type)
  return simplifiedText;
}

/**
 * Builds a map of contexts to their providers and consumers
 */
function buildContextMap(
  componentNames: ReadonlyArray<string>,
  projectReader: ProjectDocReader,
): Map<string, { providers: string[]; consumers: string[] }> {
  const contextMap = new Map<string, { providers: string[]; consumers: string[] }>();

  for (const componentName of componentNames) {
    const jsDoc = projectReader.getComponentJsDocMeta(componentName);
    if (!jsDoc) continue;

    // Check for @provides tags (can be multiple)
    const providesTags = getAllTagTexts(jsDoc, 'provides');
    for (const contextName of providesTags) {
      if (!contextMap.has(contextName)) {
        contextMap.set(contextName, { providers: [], consumers: [] });
      }
      contextMap.get(contextName)!.providers.push(componentName);
    }

    // Check for @consumes tags (can be multiple)
    const consumesTags = getAllTagTexts(jsDoc, 'consumes');
    for (const contextName of consumesTags) {
      if (!contextMap.has(contextName)) {
        contextMap.set(contextName, { providers: [], consumers: [] });
      }
      contextMap.get(contextName)!.consumers.push(componentName);
    }
  }

  return contextMap;
}

async function generateComponentDescription(
  componentName: string,
  projectReader: ProjectDocReader,
): Promise<{ [locale: string]: string } | undefined> {
  const componentJsDoc = projectReader.getComponentJsDocMeta(componentName);
  if (componentJsDoc) {
    const desc: { [locale: string]: string } = {};
    if (componentJsDoc.text) {
      desc['en-US'] = await marked.parse(componentJsDoc.text);
    }
    // Check for @since tag
    const sinceTag = getTagText(componentJsDoc, 'since');
    if (sinceTag?.text) {
      desc['en-US'] = `${desc['en-US'] ?? ''}<p>Available since Recharts ${sinceTag.text}</p>`;
    }
    return desc;
  }
  return undefined;
}

/**
 * Generates API documentation for a single component
 */
async function generateApiDoc(
  componentName: string,
  projectReader: ProjectDocReader,
  contextMap: Map<string, { providers: string[]; consumers: string[] }>,
): Promise<ApiDoc> {
  const props: ApiProps[] = [];
  const rechartsPropNames = projectReader.getRechartsPropsOf(componentName);

  for (const propName of rechartsPropNames) {
    const comment = projectReader.getCommentOf(componentName, propName);
    const defaultValue = projectReader.getDefaultValueOf(componentName, propName);

    // Extract type information
    const typeInfo = projectReader.getTypeOf(componentName, propName);
    const typeString = typeInfo ? simplifyType(typeInfo.name, typeInfo.isInline) : 'Any';

    // Determine if optional
    const isOptional = projectReader.isOptionalProp(componentName, propName);

    const prop: ApiProps = {
      name: propName,
      type: typeString,
      isOptional,
    };

    // Add description if available
    if (comment) {
      prop.desc = {
        // eslint-disable-next-line no-await-in-loop
        'en-US': await marked.parse(comment),
      };
    }

    // Add default value if available
    if (defaultValue.type === 'known') {
      prop.defaultVal = defaultValue.value as
        | string
        | number
        | boolean
        | Array<unknown>
        | Record<string, unknown>
        | null;
    }

    // Add examples if available
    const examples = projectReader.getExamplesOf(componentName, propName);
    if (examples.length > 0) {
      prop.format = examples;
    }

    props.push(prop);
  }

  const apiDoc: ApiDoc = {
    name: componentName,
    props,
  };

  // Get component-level JSDoc metadata
  const componentJsDoc = projectReader.getComponentJsDocMeta(componentName);
  if (componentJsDoc) {
    apiDoc.desc = await generateComponentDescription(componentName, projectReader);

    // Check for @provides tags - this component provides context to children
    const providesTags = getAllTagTexts(componentJsDoc, 'provides');
    if (providesTags.length > 0) {
      const allChildren = new Set<string>();
      for (const contextName of providesTags) {
        const contextInfo = contextMap.get(contextName);
        if (contextInfo) {
          contextInfo.consumers.forEach(consumer => allChildren.add(consumer));
        }
      }
      if (allChildren.size > 0) {
        apiDoc.childrenComponents = Array.from(allChildren).sort();
      }
    }

    // Check for @consumes tags - this component consumes context from parents
    const consumesTags = getAllTagTexts(componentJsDoc, 'consumes');
    if (consumesTags.length > 0) {
      const allParents = new Set<string>();
      for (const contextName of consumesTags) {
        const contextInfo = contextMap.get(contextName);
        if (contextInfo) {
          contextInfo.providers.forEach(provider => allParents.add(provider));
        }
      }
      if (allParents.size > 0) {
        apiDoc.parentComponents = Array.from(allParents).sort();
      }
    }
  }

  return apiDoc;
}

/**
 * Custom stringify that converts HTML strings to JSX.
 *
 * This function is intentionally not adding new lines or indentation
 * because we assume that prettier runs immediately after this generation step.
 */
function stringifyApiDoc(apiDoc: ApiDoc): string {
  let result = `{"name": "${apiDoc.name}","props": [`;

  apiDoc.props.forEach(prop => {
    result += `{`;
    result += `"name": "${prop.name}",`;
    result += `"type": ${JSON.stringify(prop.type)},`;
    result += `"isOptional": ${prop.isOptional},`;

    if (prop.desc) {
      result += `"desc": {`;
      for (const [locale, html] of Object.entries(prop.desc)) {
        // Write HTML as JSX without quotes. Wrap in <section> to ensure valid JSX.
        result += `"${locale}": (<section>${html}</section>),`;
      }
      result += `},`;
    }

    if (prop.defaultVal !== undefined) {
      result += `"defaultVal": ${JSON.stringify(prop.defaultVal)},`;
    }

    if (prop.format !== undefined) {
      result += `"format": ${JSON.stringify(prop.format)},`;
    }

    result += `},`;
  });
  result += `],`;
  // Add component-level description if at least one language is available                                                                                                                                  │
  if (apiDoc.desc && Object.values(apiDoc.desc).some(Boolean)) {
    result += `"desc": {`;
    for (const [locale, html] of Object.entries(apiDoc.desc)) {
      if (!html) continue;
      // Write HTML as JSX without quotes. Wrap in <section> to ensure valid JSX.
      result += `"${locale}": (<section>${html}</section>),`;
    }
    result += `},`;
  }
  // Add parent components if available
  if (apiDoc.parentComponents && apiDoc.parentComponents.length > 0) {
    result += `"parentComponents": ${JSON.stringify(apiDoc.parentComponents)},`;
  }
  // Add children components if available
  if (apiDoc.childrenComponents && apiDoc.childrenComponents.length > 0) {
    result += `"childrenComponents": ${JSON.stringify(apiDoc.childrenComponents)},`;
  }
  result += `}`;
  return result;
}

/**
 * Writes the API doc to a TypeScript file
 */
function writeApiDocFile(apiDoc: ApiDoc, outputPath: string): void {
  const varName = `${apiDoc.name}API`;

  const fileContent = `import { ApiDoc } from './types.ts';

export const ${varName}: ApiDoc = ${stringifyApiDoc(apiDoc)};
`;

  fs.writeFileSync(outputPath, fileContent, 'utf-8');
  console.log(`✓ Generated ${outputPath}`);
}

/**
 * Main function
 */
async function main() {
  const componentsToGenerate = OMNIDOC_AUTOMATED_API_DOCS_COMPONENTS;

  const projectReader = new ProjectDocReader();

  // Build context map from all public components, not just the ones we're generating
  // This ensures we can find all providers and consumers even if they're not being generated
  const allComponentNames = projectReader.getPublicComponentNames();
  const contextMap = buildContextMap(allComponentNames, projectReader);

  console.log('Generating API documentation for:', componentsToGenerate);

  for (const componentName of componentsToGenerate) {
    try {
      // eslint-disable-next-line no-await-in-loop
      const apiDoc = await generateApiDoc(componentName, projectReader, contextMap);
      const outputPath = path.join(OUTPUT_DIR, `${componentName}API.tsx`);
      writeApiDocFile(apiDoc, outputPath);
    } catch (error) {
      console.error(`✗ Failed to generate documentation for ${componentName}:`, error);
    }
  }

  console.log('\nDone! Remember to:');
  console.log('1. Review the generated files');
  console.log('2. Add imports to www/src/docs/api/index.ts if needed');
  console.log('3. Run tests to verify consistency');
}

if (require.main === module) {
  main();
}

export { generateApiDoc, writeApiDocFile };
