import { describe, expect, it, test } from 'vitest';
import { shallowEqual } from 'react-redux';
import { ProjectDocReader } from './readProject';
import { ApiDocReader } from './readApiDoc';
import { DefaultValue } from './DocReader';
import { isNotNil } from '../src/util/DataUtils';
import { apiCates } from '../www/src/docs/apiCates';
import { allApiDocs } from '../www/src/docs/api/index';

describe('omnidoc - documentation consistency', () => {
  const projectReader = new ProjectDocReader();
  const apiDocReader = new ApiDocReader();

  it('if it is documented then it must actually exist in the project', () => {
    const projectSymbols = new Set(projectReader.getAllRuntimeExportedNames());
    const apiDocSymbols = apiDocReader.getPublicSymbolNames();

    const missingInProject: string[] = [];

    for (const symbol of apiDocSymbols) {
      if (!projectSymbols.has(symbol)) {
        missingInProject.push(symbol);
      }
    }

    if (missingInProject.length > 0) {
      console.error(
        `Found ${missingInProject.length} symbol(s) documented in API docs but not exported from the project:`,
        missingInProject,
      );
    }

    expect(missingInProject).toEqual([]);
  });

  it('should have autogenerated API docs for each exports that is not a type', () => {
    const projectSymbols = new Set(projectReader.getAllRuntimeExportedNames());
    for (const symbol of projectSymbols) {
      expect(allApiDocs).toHaveProperty(symbol);
    }
  });

  it('should have a mapping defined in apiCates for each export because without this mapping, navigation will not render a link', () => {
    const componentsThatHaveApiCategoryMapping = apiCates.flatMap(cat => cat.items);

    for (const symbol of projectReader.getAllRuntimeExportedNames()) {
      expect(componentsThatHaveApiCategoryMapping).toContain(symbol);
    }
  });

  describe('default props consistency', () => {
    function stringify(value: unknown): string {
      if (typeof value === 'string') {
        return value;
      }
      try {
        return JSON.stringify(value);
      } catch {
        return String(value);
      }
    }

    function stringifyDefaultValue(defaultValue: DefaultValue): DefaultValue {
      if (defaultValue.type === 'known') {
        return {
          type: 'known',
          value: stringify(defaultValue.value),
        };
      }
      return defaultValue;
    }

    function stripQuotes(str: unknown) {
      if (typeof str === 'string') {
        return str.replace(/^['"]|['"]$/g, '');
      }
      return stringify(str);
    }

    function compareValues(val1: unknown, val2: unknown) {
      if (typeof val1 === 'object' && typeof val2 === 'object') {
        return shallowEqual(val1, val2);
      }
      return stripQuotes(val1) === stripQuotes(val2);
    }

    function compareDefaultValues(
      documentedDefaultValue: DefaultValue,
      actualDefaultValue: DefaultValue,
    ): string | null {
      if (documentedDefaultValue.type === 'unreadable' || actualDefaultValue.type === 'unreadable') {
        return null;
      }
      if (documentedDefaultValue.type === 'known' && actualDefaultValue.type === 'known') {
        if (!compareValues(documentedDefaultValue.value, actualDefaultValue.value)) {
          return `Documented default value "${documentedDefaultValue.value}" [${typeof documentedDefaultValue.value}], but actually in project it is "${stringify(actualDefaultValue.value)}" [${typeof actualDefaultValue.value}]`;
        }
        return null;
      }
      if (documentedDefaultValue.type === 'none' && actualDefaultValue.type !== 'none') {
        return `Default value is ${actualDefaultValue.value} but it is not documented`;
      }
      if (documentedDefaultValue.type !== 'none' && actualDefaultValue.type === 'none') {
        return `Documented default value ${documentedDefaultValue.value}, but actually none exists in the project`;
      }
      return null;
    }

    test.each(projectReader.getPublicComponentNames())(
      'if a %s prop is documented with a @default tag, it should match the actual default prop in the project',
      component => {
        const result: Array<string> = [];

        const allProps = projectReader.getRechartsPropsOf(component);
        for (const prop of allProps) {
          const propMeta = projectReader.getPropMeta(component, prop);
          const problems = propMeta
            .map(meta => {
              /*
               * Because everything coming out of the JSDoc is a string,
               * we need to convert the actual default value to string for comparison.
               */
              return compareDefaultValues(
                meta.defaultValueFromJSDoc,
                stringifyDefaultValue(meta.defaultValueFromObject),
              );
            })
            .filter(isNotNil)
            .map(description => `Component "${component}", prop "${prop}": ${description}`);
          if (problems) {
            result.push(...problems);
          }
        }

        expect(result).toEqual([]);
      },
    );
  });
});
