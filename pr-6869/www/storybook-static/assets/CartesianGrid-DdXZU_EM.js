import{i as x,r as o}from"./iframe-YjsnRhKk.js";import{e as q,f as W,h as H,c as _,b as A,i as P,j as E,w as G,D as O,k as N}from"./arrayEqualityCheck-BJwRC6MI.js";import{g as T,d as F}from"./CartesianAxis-B3Ooqwxn.js";import{g as C}from"./axisSelectors-DDrqqiFr.js";import{r as L,b as D}from"./resolveDefaultProps-Z_TS6-YD.js";import{Z as $}from"./ZIndexLayer-B9GJT-1H.js";const R=t=>{const{fill:i}=t;if(!i||i==="none")return null;const{fillOpacity:n,x:r,y:e,width:u,height:h,ry:d}=t;return o.createElement("rect",{x:r,y:e,ry:d,width:u,height:h,stroke:"none",fill:i,fillOpacity:n,className:"recharts-cartesian-grid-bg"})};function S({option:t,lineItemProps:i}){let n;if(o.isValidElement(t))n=o.cloneElement(t,i);else if(typeof t=="function")n=t(i);else{const{x1:r,y1:e,x2:u,y2:h,key:d,...f}=i,{offset:l,...s}=D(f)??{};n=o.createElement("line",{...s,x1:r,y1:e,x2:u,y2:h,fill:"none",key:d})}return n}function Z(t){const{x:i,width:n,horizontal:r=!0,horizontalPoints:e}=t;if(!r||!e||!e.length)return null;const{xAxisId:u,yAxisId:h,...d}=t,f=e.map((l,s)=>{const a={...d,x1:i,y1:l,x2:i+n,y2:l,key:`line-${s}`,index:s};return o.createElement(S,{key:`line-${s}`,option:r,lineItemProps:a})});return o.createElement("g",{className:"recharts-cartesian-grid-horizontal"},f)}function B(t){const{y:i,height:n,vertical:r=!0,verticalPoints:e}=t;if(!r||!e||!e.length)return null;const{xAxisId:u,yAxisId:h,...d}=t,f=e.map((l,s)=>{const a={...d,x1:l,y1:i,x2:l,y2:i+n,key:`line-${s}`,index:s};return o.createElement(S,{option:r,lineItemProps:a,key:`line-${s}`})});return o.createElement("g",{className:"recharts-cartesian-grid-vertical"},f)}function M(t){const{horizontalFill:i,fillOpacity:n,x:r,y:e,width:u,height:h,horizontalPoints:d,horizontal:f=!0}=t;if(!f||!i||!i.length||d==null)return null;const l=d.map(a=>Math.round(a+e-e)).sort((a,c)=>a-c);e!==l[0]&&l.unshift(0);const s=l.map((a,c)=>{const p=l[c+1],m=p==null?e+h-a:p-a;if(m<=0)return null;const y=c%i.length;return o.createElement("rect",{key:`react-${c}`,y:a,x:r,height:m,width:u,stroke:"none",fill:i[y],fillOpacity:n,className:"recharts-cartesian-grid-bg"})});return o.createElement("g",{className:"recharts-cartesian-gridstripes-horizontal"},s)}function U(t){const{vertical:i=!0,verticalFill:n,fillOpacity:r,x:e,y:u,width:h,height:d,verticalPoints:f}=t;if(!i||!n||!n.length)return null;const l=f.map(a=>Math.round(a+e-e)).sort((a,c)=>a-c);e!==l[0]&&l.unshift(0);const s=l.map((a,c)=>{const p=l[c+1],m=p==null?e+h-a:p-a;if(m<=0)return null;const y=c%n.length;return o.createElement("rect",{key:`react-${c}`,x:a,y:u,width:m,height:d,stroke:"none",fill:n[y],fillOpacity:r,className:"recharts-cartesian-grid-bg"})});return o.createElement("g",{className:"recharts-cartesian-gridstripes-vertical"},s)}const X=({xAxis:t,width:i,height:n,offset:r},e)=>E(T({...F,...t,ticks:N(t),viewBox:{x:0,y:0,width:i,height:n}}),r.left,r.left+r.width,e),Y=({yAxis:t,width:i,height:n,offset:r},e)=>E(T({...F,...t,ticks:N(t),viewBox:{x:0,y:0,width:i,height:n}}),r.top,r.top+r.height,e),j={horizontal:!0,vertical:!0,horizontalPoints:[],verticalPoints:[],stroke:"#ccc",fill:"none",verticalFill:[],horizontalFill:[],xAxisId:0,yAxisId:0,syncWithTicks:!1,zIndex:O.grid};function z(t){const i=q(),n=W(),r=H(),e={...L(t,j),x:x(t.x)?t.x:r.left,y:x(t.y)?t.y:r.top,width:x(t.width)?t.width:r.width,height:x(t.height)?t.height:r.height},{xAxisId:u,yAxisId:h,x:d,y:f,width:l,height:s,syncWithTicks:a,horizontalValues:c,verticalValues:p}=e,k=_(),m=A(g=>C(g,"xAxis",u,k)),y=A(g=>C(g,"yAxis",h,k));if(!P(l)||!P(s)||!x(d)||!x(f))return null;const V=e.verticalCoordinatesGenerator||X,I=e.horizontalCoordinatesGenerator||Y;let{horizontalPoints:w,verticalPoints:v}=e;if((!w||!w.length)&&typeof I=="function"){const g=c&&c.length,b=I({yAxis:y?{...y,ticks:g?c:y.ticks}:void 0,width:i??l,height:n??s,offset:r},g?!0:a);G(),Array.isArray(b)&&(w=b)}if((!v||!v.length)&&typeof V=="function"){const g=p&&p.length,b=V({xAxis:m?{...m,ticks:g?p:m.ticks}:void 0,width:i??l,height:n??s,offset:r},g?!0:a);G(),Array.isArray(b)&&(v=b)}return o.createElement($,{zIndex:e.zIndex},o.createElement("g",{className:"recharts-cartesian-grid"},o.createElement(R,{fill:e.fill,fillOpacity:e.fillOpacity,x:e.x,y:e.y,width:e.width,height:e.height,ry:e.ry}),o.createElement(M,{...e,horizontalPoints:w}),o.createElement(U,{...e,verticalPoints:v}),o.createElement(Z,{...e,offset:r,horizontalPoints:w,xAxis:m,yAxis:y}),o.createElement(B,{...e,offset:r,verticalPoints:v,xAxis:m,yAxis:y})))}z.displayName="CartesianGrid";try{z.displayName="CartesianGrid",z.__docgenInfo={description:"Renders background grid with lines and fill colors in a Cartesian chart.",displayName:"CartesianGrid",props:{horizontalCoordinatesGenerator:{defaultValue:null,description:`A function that generates the y-coordinates of all horizontal lines.
@see {@link https://codesandbox.io/p/sandbox/cartesian-grid-with-coordinate-generators-my38cg?file=%2Fsrc%2FApp.tsx Cartesian grid with coordinate generators}`,name:"horizontalCoordinatesGenerator",required:!1,type:{name:"HorizontalCoordinatesGenerator"}},verticalCoordinatesGenerator:{defaultValue:null,description:`A function that generates the x-coordinates of all vertical lines.
@see {@link https://codesandbox.io/p/sandbox/cartesian-grid-with-coordinate-generators-my38cg?file=%2Fsrc%2FApp.tsx Cartesian grid with coordinate generators}`,name:"verticalCoordinatesGenerator",required:!1,type:{name:"VerticalCoordinatesGenerator"}},horizontal:{defaultValue:null,description:`If set false, no horizontal grid lines will be drawn.
@defaultValue true`,name:"horizontal",required:!1,type:{name:"GridLineType"}},vertical:{defaultValue:null,description:`If set false, no vertical grid lines will be drawn.
@defaultValue true`,name:"vertical",required:!1,type:{name:"GridLineType"}},horizontalPoints:{defaultValue:null,description:`Array of coordinates in pixels where to draw horizontal grid lines.
Has priority over syncWithTicks and horizontalValues.
@defaultValue []`,name:"horizontalPoints",required:!1,type:{name:"number[]"}},verticalPoints:{defaultValue:null,description:`Array of coordinates in pixels where to draw vertical grid lines.
Has priority over syncWithTicks and verticalValues.
@defaultValue []`,name:"verticalPoints",required:!1,type:{name:"number[]"}},verticalFill:{defaultValue:null,description:`Defines background color of stripes.

The values from this array will be passed in as the \`fill\` property in a \`rect\` SVG element.
For possible values see: https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill#rect

In case there are more stripes than colors, the colors will start from beginning.
So for example: verticalFill['yellow', 'black'] produces a pattern of yellow|black|yellow|black

If this is undefined, or an empty array, then there is no background fill.
Note: Grid lines will be rendered above these background stripes.
@defaultValue []`,name:"verticalFill",required:!1,type:{name:"string[]"}},horizontalFill:{defaultValue:null,description:`Defines background color of stripes.

The values from this array will be passed in as the \`fill\` property in a \`rect\` SVG element.
For possible values see: https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill#rect

In case there are more stripes than colors, the colors will start from beginning.
So for example: horizontalFill['yellow', 'black'] produces a pattern of yellow|black|yellow|black

If this is undefined, or an empty array, then there is no background fill.
Note: Grid lines will be rendered above these background stripes.
@defaultValue []`,name:"horizontalFill",required:!1,type:{name:"string[]"}},syncWithTicks:{defaultValue:null,description:`If true, only the lines that correspond to the axes ticks values will be drawn.
If false, extra lines could be added for each axis (at min and max coordinates), if there will not such ticks.
horizontalPoints, verticalPoints, horizontalValues, verticalValues have priority over syncWithTicks.
@defaultValue false`,name:"syncWithTicks",required:!1,type:{name:"boolean"}},horizontalValues:{defaultValue:null,description:`Array of values, where horizontal lines will be drawn. Numbers or strings, in dependence on axis type.
Has priority over syncWithTicks but not over horizontalPoints.`,name:"horizontalValues",required:!1,type:{name:"string[] | number[]"}},verticalValues:{defaultValue:null,description:`Array of values, where vertical lines will be drawn. Numbers or strings, in dependence on axis type.
Has priority over syncWithTicks but not over verticalPoints.`,name:"verticalValues",required:!1,type:{name:"string[] | number[]"}},xAxisId:{defaultValue:null,description:`The id of XAxis which is corresponding to the data. Required when there are multiple XAxes.
@defaultValue 0`,name:"xAxisId",required:!1,type:{name:"AxisId"}},yAxisId:{defaultValue:null,description:`The id of YAxis which is corresponding to the data. Required when there are multiple YAxes.
@defaultValue 0`,name:"yAxisId",required:!1,type:{name:"AxisId"}},zIndex:{defaultValue:null,description:`Z-Index of this component and its children. The higher the value,
the more on top it will be rendered.
Components with higher zIndex will appear in front of components with lower zIndex.
If undefined or 0, the content is rendered in the default layer without portals.
@defaultValue -100`,name:"zIndex",required:!1,type:{name:"number"}}}}}catch{}export{z as C};
